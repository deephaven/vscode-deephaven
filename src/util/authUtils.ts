import { generateKeyPairSync, sign } from 'node:crypto';
import type {
  EnterpriseClient,
  LoginCredentials as DheLoginCredentials,
} from '@deephaven-enterprise/jsapi-types';
import type {
  Base64KeyPair,
  Base64Nonce,
  Base64PrivateKey,
  Base64PublicKey,
  Base64Signature,
  KeyPairType,
} from '../types';
import { Logger } from './Logger';

const logger = new Logger('UserLoginController');

/*
 * Named curve to use for generating key pairs.
 * Note that 'prime256v1' is synonymous with 'secp256r1'.
 */
const NAMED_CURVE = 'prime256v1' as const;

/**
 * Generate a base64 encoded asymmetric key pair using eliptic curve.
 * @returns The base64 encoded public and private keys.
 */
export function generateBase64KeyPair(): Base64KeyPair {
  const type: KeyPairType = 'ec';

  const { publicKey: publicKeyBuffer, privateKey: privateKeyBuffer } =
    generateKeyPairSync(type, {
      namedCurve: NAMED_CURVE,
      publicKeyEncoding: { type: 'spki', format: 'der' },
      privateKeyEncoding: { type: 'pkcs8', format: 'der' },
    });

  const publicKey = publicKeyBuffer.toString('base64') as Base64PublicKey;
  const privateKey = privateKeyBuffer.toString('base64') as Base64PrivateKey;

  return { type, publicKey, privateKey };
}

/**
 * Prepend a sentinal value to a public key based on the given type. The
 * sentinel is the uppercase type followed by a colon.
 * @param type Keypair type.
 * @param key Base64 encoded public key.
 * @returns The key with the sentinel prepended.
 */
export function keyWithSentinel(type: 'ec', key: Base64PublicKey): string {
  const sentinelBytes = Buffer.from(`${type.toUpperCase()}:`);
  const keyBytes = Buffer.from(key, 'base64');

  return Buffer.concat([sentinelBytes, keyBytes]).toString('base64');
}

/**
 * Sign a nonce using a private key.
 * @param nonce
 * @param privateKey
 * @returns The base64 encoded signature.
 */
export function signWithPrivateKey(
  nonce: Base64Nonce,
  privateKey: Base64PrivateKey
): Base64Signature {
  const nonceBytes = Buffer.from(nonce, 'base64');
  const privateKeyBytes = Buffer.from(privateKey, 'base64');

  return sign('sha256', nonceBytes, {
    key: privateKeyBytes,
    format: 'der',
    type: 'pkcs8',
  }).toString('base64') as Base64Signature;
}

// Temporary until `jaspi-types` is updated on DHE servers
declare module '@deephaven-enterprise/jsapi-types' {
  // eslint-disable-next-line no-unused-vars
  interface EnterpriseClient {
    challengeResponse: (
      signedNonce: Base64Signature,
      publicKeyWithSentinel: string,
      username: string,
      operateAs: string
    ) => Promise<unknown>;
    getChallengeNonce(): Promise<{
      algorithm: 'SHA256withDSA';
      nonce: Base64Nonce;
    }>;
  }
}

/**
 * Upload a public key to a DHE server.
 * @param dheClient
 * @param dheCredentials
 * @param publicKey
 * @param type
 * @returns The response from the server.
 */
export async function uploadPublicKey(
  dheClient: EnterpriseClient,
  dheCredentials: DheLoginCredentials,
  publicKey: Base64PublicKey,
  type: KeyPairType
): Promise<Response> {
  await dheClient.login(dheCredentials);

  const { dbAclWriterHost, dbAclWriterPort } =
    await dheClient.getServerConfigValues();

  const body = {
    user: dheCredentials.username,
    encodedStr: keyWithSentinel(type, publicKey),
    algorithm: type.toUpperCase(),
    comment: `Generated by vscode extension ${new Date().toISOString()}`,
  };

  return fetch(`https://${dbAclWriterHost}:${dbAclWriterPort}/acl/publickey`, {
    method: 'POST',
    headers: {
      /* eslint-disable @typescript-eslint/naming-convention */
      Authorization: await dheClient.createAuthToken('DbAclWriteServer'),
      'Content-Type': 'application/json',
      /* eslint-enable @typescript-eslint/naming-convention */
    },
    body: JSON.stringify(body),
  });
}

/**
 * Authenticate using public / private key.
 * @param dheClient The DHE client to use.
 * @param keyPair The base64 encoded key pair + type.
 * @param username The username to authenticate as.
 * @param operateAs The optional username to operate as. Defaults to `username`.
 */
export async function authWithPrivateKey({
  dheClient,
  keyPair: { type, publicKey, privateKey },
  username,
  operateAs = username,
}: {
  dheClient: EnterpriseClient;
  keyPair: Base64KeyPair;
  username: string;
  operateAs?: string;
}): Promise<void> {
  try {
    const { nonce } = await dheClient.getChallengeNonce();
    const signedNonce = signWithPrivateKey(nonce, privateKey);

    await dheClient.challengeResponse(
      signedNonce,
      keyWithSentinel(type, publicKey),
      username,
      operateAs
    );
  } catch (e) {
    logger.error(
      'An error occurred when signing in with public / private key',
      e
    );
    throw e;
  }
}
