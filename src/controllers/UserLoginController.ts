import {
  deletePublicKeys,
  generateBase64KeyPair,
  loginClientWithKeyPair,
  loginClientWithPassword,
  uploadPublicKey,
  type Base64KeyPair,
  type AuthenticatedClient as DheAuthenticatedClient,
  type Username,
} from '@deephaven-enterprise/auth-nodejs';
import type { URLMap } from '../services';
import { ControllerBase } from './ControllerBase';
import {
  CREATE_AUTHENTICATED_CLIENT_CMD,
  GENERATE_DHE_KEY_PAIR_CMD,
} from '../common';
import { Logger, runUserLoginWorkflow } from '../util';
import type {
  IDheClientFactory,
  ISecretService,
  IToastService,
  ServerState,
} from '../types';
import { hasInteractivePermission } from '../dh/dhe';

const logger = new Logger('UserLoginController');

/**
 * Controller for user login.
 */
export class UserLoginController extends ControllerBase {
  constructor(
    dheClientCache: URLMap<DheAuthenticatedClient>,
    dheClientFactory: IDheClientFactory,
    secretService: ISecretService,
    toastService: IToastService
  ) {
    super();

    this.dheClientCache = dheClientCache;
    this.dheClientFactory = dheClientFactory;
    this.secretService = secretService;
    this.toast = toastService;

    this.registerCommand(
      GENERATE_DHE_KEY_PAIR_CMD,
      this.onDidRequestGenerateDheKeyPair
    );

    this.registerCommand(
      CREATE_AUTHENTICATED_CLIENT_CMD,
      this.onCreateAuthenticatedClient
    );
  }

  private readonly dheClientCache: URLMap<DheAuthenticatedClient>;
  private readonly dheClientFactory: IDheClientFactory;
  private readonly secretService: ISecretService;
  private readonly toast: IToastService;

  /**
   * Login with a given key pair and remove the public key from the server.
   * @param serverUrl The server URL to remove the key from.
   * @param userName The user name to remove the key for.
   * @param keyPair The key pair that contains the public key to be removed. The
   * key pair is needed since a login is required before the deletion.
   */
  private _deleteUserPublicKey = async (
    serverUrl: URL,
    userName: Username,
    keyPair: Base64KeyPair
  ): Promise<void> => {
    const dheClient = await loginClientWithKeyPair(
      await this.dheClientFactory(serverUrl),
      {
        type: 'keyPair',
        username: userName,
        keyPair,
      }
    );

    const { type, publicKey } = keyPair;

    try {
      await deletePublicKeys({
        dheClient,
        userName,
        publicKeys: [publicKey],
        type,
      });
    } finally {
      dheClient.disconnect();
    }
  };

  /**
   * Handle request for generating a DHE key pair.
   * @param serverState The server state to generate the key pair for.
   */
  onDidRequestGenerateDheKeyPair = async (
    serverState: ServerState
  ): Promise<void> => {
    const serverUrl = serverState.url;

    const title = 'Generate Private Key';

    const userLoginPreferences =
      await this.secretService.getUserLoginPreferences(serverUrl);

    const credentials = await runUserLoginWorkflow({
      title,
      userLoginPreferences,
    });

    // Cancelled by user
    if (credentials == null) {
      return;
    }

    const keyPair = generateBase64KeyPair();
    const { type, publicKey } = keyPair;

    const dheClient = await loginClientWithPassword(
      await this.dheClientFactory(serverUrl),
      credentials
    );

    await uploadPublicKey({
      dheClient,
      userName: credentials.username,
      comment: `Generated by VSCode ${new Date().toISOString()}`,
      publicKey,
      type,
    });

    const existingServerKeys =
      await this.secretService.getServerKeys(serverUrl);

    // Attempt to remove older keys / previously generated keys for other users
    // from the server. Ignore errors since this is an optimistic cleanup, and
    // it's possible the keys have already been removed.
    for (const [username, keyPair] of Object.entries(existingServerKeys)) {
      try {
        void this._deleteUserPublicKey(
          serverUrl,
          username as Username,
          keyPair
        );
      } catch (err) {
        logger.error(err);
      }
    }

    // Store the new private key for the user
    await this.secretService.storeServerKeys(serverUrl, {
      [credentials.username]: keyPair,
    });

    this.toast.info(
      `Successfully generated a new key pair for ${credentials.username}.`
    );
  };

  /**
   * Create an authenticated client.
   * @param serverUrl The server URL to create a client for.
   * @param operateAsAnotherUser Whether to operate as another user.
   * @returns A promise that resolves when the client has been created or failed.
   */
  onCreateAuthenticatedClient = async (
    serverUrl: URL,
    operateAsAnotherUser: boolean
  ): Promise<void> => {
    const title = 'Login';

    const secretKeys = await this.secretService.getServerKeys(serverUrl);
    const userLoginPreferences =
      await this.secretService.getUserLoginPreferences(serverUrl);

    const privateKeyUserNames = Object.keys(secretKeys) as Username[];

    const credentials = await runUserLoginWorkflow({
      title,
      userLoginPreferences,
      privateKeyUserNames,
      showOperatesAs: operateAsAnotherUser,
    });

    // Cancelled by user
    if (credentials == null) {
      this.toast.info('Login cancelled.');
      return;
    }

    const { username, operateAs = username } = credentials;

    await this.secretService.storeUserLoginPreferences(serverUrl, {
      lastLogin: username,
      operateAsUser: {
        ...userLoginPreferences.operateAsUser,
        [username]: operateAs,
      },
    });

    const dheClient = await this.dheClientFactory(serverUrl);

    try {
      const authenticatedClient =
        credentials.type === 'password'
          ? await loginClientWithPassword(dheClient, credentials)
          : await loginClientWithKeyPair(dheClient, {
              ...credentials,
              keyPair: (await this.secretService.getServerKeys(serverUrl))?.[
                username
              ],
            });

      if (!(await hasInteractivePermission(authenticatedClient))) {
        throw new Error('User does not have interactive permissions.');
      }

      this.dheClientCache.set(serverUrl, authenticatedClient);
    } catch (err) {
      logger.error('An error occurred while connecting to DHE server:', err);
      this.dheClientCache.delete(serverUrl);

      this.toast.error('Login failed. Please check your credentials.');

      if (credentials.type === 'keyPair') {
        await this.secretService.deleteUserServerKeys(serverUrl, username);
      }
    }
  };
}
